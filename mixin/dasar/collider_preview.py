# Copyright (c) 2024 Roni Raihan
# Some code functions, generated by AI ChatGPT < https://chat.openai.com/ >

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see < https://www.gnu.org/licenses/ >.


import bpy
from bpy.props import (
    FloatProperty,
    FloatVectorProperty,
    EnumProperty,
    IntProperty,
    BoolProperty,
    CollectionProperty
)
    
def buat_ps(self, context):
    ps = bpy.data.objects.new(name="important_dont_delete_this_for_scale_benchmark", object_data=None)
    ps.empty_display_size = 0.01
    coll = bpy.data.collections.get("collider_preview")
    if not coll:
        coll = bpy.data.collections.new("collider_preview")
        bpy.context.scene.collection.children.link(coll)
    coll.objects.link(ps)
    ps.location = (0, 0, 0)
    ps.scale = (1, 1, 1)
    
    ps.lock_location[0] = True
    ps.lock_location[1] = True
    ps.lock_location[2] = True
    ps.lock_rotation[0] = True
    ps.lock_rotation[1] = True
    ps.lock_rotation[2] = True
    ps.lock_scale[0] = True
    ps.lock_scale[1] = True
    ps.lock_scale[2] = True
    ps.hide_viewport = True
    ps.hide_select = True
    
def buat_collider_Preview(self, context, id_empty, obj, vb, loc, ro, radius):
    empty = bpy.data.objects.new(name=id_empty, object_data=None)
    empty.empty_display_type = 'SPHERE'
    empty.empty_display_size = radius
    
    coll = bpy.data.collections.get("collider_preview")
    if not coll:
        coll = bpy.data.collections.new("collider_preview")
        bpy.context.scene.collection.children.link(coll)
    coll.objects.link(empty)

    empty.location = (loc[0], loc[1], loc[2])
    empty.rotation_euler = (ro[0], ro[1], ro[2])
    empty.scale = (1, 1, 1)

    empty.constraints.new(type='CHILD_OF')
    empty.constraints["Child Of"].target = obj
    empty.constraints["Child Of"].subtarget = vb.name
    
    ps = bpy.data.objects.get("important_dont_delete_this_for_scale_benchmark")
    if not ps:
        buat_ps(self, context)
        ps = bpy.data.objects.get("important_dont_delete_this_for_scale_benchmark")
    empty.constraints.new(type='COPY_SCALE')
    empty.constraints["Copy Scale"].target = ps

    empty.lock_location[0] = True
    empty.lock_location[1] = True
    empty.lock_location[2] = True
    empty.lock_rotation[0] = True
    empty.lock_rotation[1] = True
    empty.lock_rotation[2] = True
    empty.hide_select = True
    
def hapus_collider_Preview(self, context, id_empty):
    empty = bpy.data.objects.get(id_empty)
    if empty:
        bpy.data.objects.remove(empty, do_unlink=True, do_id_user=True, do_ui_user=True)
        
def buat_spring_hit_Preview(self, context, id_empty, vb):
    obj = context.object
    va = obj.data
    #bone = va.bones.active
    #vb = obj.pose.bones[bone.name]
    
    if vb.vrmprop_aktif == 'Spring' and vb.vrmprop_use_colliders == True:
        radius = vb.vrmprop_radius
        ro = (0.0, 0.0, 0.0)
        loc = obj.matrix_world @ vb.head
        id = ("%s.head" % (id_empty))
        if id not in [object.name for object in bpy.context.scene.objects]:
            buat_collider_Preview(self, context, id, obj, vb, loc, ro, radius)
        loc = obj.matrix_world @ vb.tail
        id = ("%s.tail" % (id_empty))
        if id not in [object.name for object in bpy.context.scene.objects]:
            buat_collider_Preview(self, context, id, obj, vb, loc, ro, radius)

def hapus_spring_hit_Preview(self, context, id_empty):
    id = ("%s.head" % (id_empty))
    hapus_collider_Preview(self, context, id)
    id = ("%s.tail" % (id_empty))
    hapus_collider_Preview(self, context, id)
    
def update_collider_radius(self, context):
    ob = context.object
    va = ob.data
    bone = va.bones.active
    vb = ob.pose.bones[bone.name]
    
    pilih = vb.vrmprop_collider_pilih
    id_empty = vb.vrmprop_collider[pilih].tampil
    radius = vb.vrmprop_collider[pilih].radius
    
    empty = bpy.data.objects.get(id_empty)
    if empty:
        empty.empty_display_size = radius
    
def update_collider_offset(self, context):
    ob = context.object
    va = ob.data
    bone = va.bones.active
    vb = ob.pose.bones[bone.name]
    
    pilih = vb.vrmprop_collider_pilih
    id_empty = vb.vrmprop_collider[pilih].tampil
    origin = vb.vrmprop_collider[pilih].origin
    offset = vb.vrmprop_collider[pilih].offset
    
    empty = bpy.data.objects.get(id_empty)
    if empty:
        x = origin[0] + offset[0]
        y = origin[1] + offset[1]
        z = origin[2] + offset[2]
        empty.location = (x, y, z)
    
def update_spring_hit_radius(self, context):
    ob = context.object
    va = ob.data
    #bone = va.bones.active
    #vb = ob.pose.bones[bone.name]
    
    for bone in va.bones:
        if bone.select == True:
            vb = ob.pose.bones[bone.name]
            radius = vb.vrmprop_radius
            id_empty1 = ("%s.head" % (vb.vrmprop_spring_id))
            id_empty2 = ("%s.tail" % (vb.vrmprop_spring_id))
    
            empty1 = bpy.data.objects.get(id_empty1)
            if empty1:
                empty1.empty_display_size = radius
        
            empty2 = bpy.data.objects.get(id_empty2)
            if empty2:
                empty2.empty_display_size = radius
        
def update_colliders_hiden(self, context):
    ob = context.object
    va = ob.data
    #bone = va.bones.active
    #vb = ob.pose.bones[bone.name]
    for bone in va.bones:
        if bone.select == True:
            vb = ob.pose.bones[bone.name]
            if not len(vb.vrmprop_collider) == 0:
                for item in vb.vrmprop_collider:
                    empty = bpy.data.objects.get(item.tampil)
                    if empty:
                        empty.hide_viewport = item.hiden
            
def update_show_hit(self, context):
    ob = context.object
    va = ob.data
    #bone = va.bones.active
    #vb = ob.pose.bones[bone.name]
    
    for bone in va.bones:
        if bone.select == True:
            vb = ob.pose.bones[bone.name]
            if vb.vrmprop_show_hit == True:
                hiden = False
            else:
                hiden = True
    
            id_empty1 = ("%s.head" % (vb.vrmprop_spring_id))
            empty1 = bpy.data.objects.get(id_empty1)
            if empty1:
                empty1.hide_viewport = hiden
        
            id_empty2 = ("%s.tail" % (vb.vrmprop_spring_id))
            empty2 = bpy.data.objects.get(id_empty2)
            if empty2:
                empty2.hide_viewport = hiden
        
def update_collider_rotasi_preview(self, context):
    ob = context.object
    va = ob.data
    bone = va.bones.active
    vb = ob.pose.bones[bone.name]
    
    pilih = vb.vrmprop_collider_pilih
    id_empty = vb.vrmprop_collider[pilih].tampil
    ro = vb.vrmprop_collider[pilih].rotasi_preview
    
    empty = bpy.data.objects.get(id_empty)
    if empty:
        empty.rotation_euler = ro