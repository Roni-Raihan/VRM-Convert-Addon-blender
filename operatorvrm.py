# Copyright (c) 2024 Roni Raihan
# Copyright (c) 2020-2024 kitsune.ONE team.
# Basic script / soure code by kitsune.ONE team. see < https://github.com/kitsune-ONE-team/KITSUNETSUKI-Asset-Tools >.
# Some code functions, generated by AI ChatGPT < https://chat.openai.com/ >

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see < https://www.gnu.org/licenses/ >.

#-----------------------------------------------------------------------------------

import bpy
import configparser
import os
import random
from bpy.props import (
    FloatProperty,
    EnumProperty,
    IntProperty,
    BoolProperty
)

from bpy_extras.io_utils import ExportHelper
from typing import Set, cast

from .gltfmodel import GLTFExporter

#from . import spec
from .mixin.dasar import spec

from .mixin.armature import ArmatureMixin

from .mixin.dasar.collider_preview import (
    buat_collider_Preview,
    hapus_collider_Preview,
    buat_spring_hit_Preview,
    hapus_spring_hit_Preview,
    update_collider_radius,
    update_collider_offset,
    update_spring_hit_radius,
    update_colliders_hiden,
    update_collider_rotasi_preview,
    update_show_hit
    )

bsk_ada = []
bsk_hilang = []

def update_rig_main(self,context):
    dmta = bpy.context.scene.vrm_meta
    if dmta.rig:
        bpy.ops.obj.cek_rig()
    return
def update_bs(self,context):
    global bsk_ada
    global bsk_hilang
    dmta = bpy.context.scene.vrm_meta
    bsk_terdaftar = []
    if dmta.model:
        bsk_terdaftar = [
                    dmta.joy, dmta.angry, dmta.sorrow, dmta.fun, dmta.blink, dmta.blink_l, 
                    dmta.blink_r, dmta.brows_up, dmta.brows_down, dmta.v_a, dmta.v_i, dmta.v_u,
                    dmta.v_e, dmta.v_o
                ] 
        if dmta.looktype == 'BlendShape':
            tambahkan = [dmta.lookup, dmta.lookdown, dmta.lookleft, dmta.lookright]
            bsk_terdaftar.extend(tambahkan)

        bsk_ada = []
        bsk_hilang = []
        key_blocks = dmta.model.data.shape_keys.key_blocks
        bskeys = [key.name for key in key_blocks]
        bsk_ada = [item for item in bsk_terdaftar if item in bskeys]
        bsk_hilang_filet = [item for item in bsk_terdaftar if item not in bsk_ada]
        bsk_hilang = [item for item in bsk_hilang_filet if not item == '']
        #print (bsk_ada)
        #print (bsk_hilang)

    return

class VRMExporter(ArmatureMixin, GLTFExporter):
    def __init__(self, args):
        super().__init__(args)

        self._z_up = False
        self._pose_freeze = True
        self._export_type = 'all'

    def _add_vrm_thumbnail(self, gltf_node, filepath):
        dmta = bpy.context.scene.vrm_meta
        gltf_sampler = {
            'name': os.path.basename(filepath),
            'wrapS': spec.CLAMP_TO_EDGE,
            'wrapT': spec.CLAMP_TO_EDGE,
        }
        gltf_node['samplers'].append(gltf_sampler)

        gltf_image = {
            'name': os.path.basename(filepath),
            'mimeType': 'image/png',
#            'extras': {
#                'uri': filepath,
#            }
        }
        gltf_node['images'].append(gltf_image)
        
        gltf_image['extras'] = {}
        if dmta.gambar.packed_file:
            gltf_image['extras']['data'] = dmta.gambar.packed_file.data
        else:
            gltf_image['extras']['uri'] = filepath

        gltf_texture = {
            'sampler': len(gltf_node['samplers']) - 1,
            'source': len(gltf_node['images']) - 1,
        }
        gltf_node['textures'].append(gltf_texture)

        gltf_node['extensions']['VRM']['meta']['texture'] = len(gltf_node['textures']) - 1

    def make_root_node(self):
        gltf_node = super().make_root_node()

        data = {}
        dmta = bpy.context.scene.vrm_meta
            
        vrm_meta = {
            'exporterVersion': gltf_node['asset']['generator'],
            'specVersion': '0.0',

            'meta': {
                'title': dmta.nama,
                'version': dmta.versi_model,
                'author': dmta.author,
                'contactInformation': dmta.contact,
                'reference': dmta.reference,
                'texture': 0,  # thumbnail texture
                'allowedUserName': dmta.alloweduser,
                'violentUssageName': dmta.violentussage,
                'sexualUssageName': 'Disallow',
                'commercialUssageName': dmta.commercial,
                'otherPermissionUrl': dmta.otherPermissionUrl,
                'licenseName': dmta.license,
                'otherLicenseUrl': dmta.licenseurl,
            },

            'humanoid': {
                'armStretch': dmta.armstretch,
                'legStretch': dmta.legstretch,
                'lowerArmTwist': dmta.lowerarmtwist, # LowerArm bone roll
                'upperArmTwist': dmta.upperarmtwist, # UpperArm bone roll
                'lowerLegTwist': dmta.lowerlegtwist, # LowerLeg bone roll
                'upperLegTwist': dmta.upperlegtwist, # UpperLeg bone roll
                'feetSpacing': dmta.feetspacing,
                'hasTranslationDoF': dmta.translationdof,
                'humanBones': [],
            },

            'firstPerson': {
                'firstPersonBone': None,
                'firstPersonBoneOffset': {
                    'x': 0,
                    'y': 0,
                    'z': 0,
                },
                'meshAnnotations': [],
                'lookAtTypeName': dmta.looktype,
                'lookAtHorizontalInner': None,
                'lookAtHorizontalOuter': None,
                'lookAtVerticalDown': None,
                'lookAtVerticalUp': None,
            },

            'blendShapeMaster': {
                'blendShapeGroups': [],
            },
            'secondaryAnimation': {
                'boneGroups': [],
                'colliderGroups': [],
            },
            'materialProperties': [],
        }

        gltf_node['extensionsUsed'].append('VRM')
        gltf_node['extensions']['VRM'] = vrm_meta
        gltf_node['materials'] = []

        # make thumbnail
        if dmta.gambar :
            sumber_gambar = bpy.path.abspath(dmta.gambar.filepath)
            self._add_vrm_thumbnail(gltf_node, sumber_gambar)
        else :
            if self._inputs:
                prefix = os.path.basename(self._inputs[0]).replace('.blend', '.png')
                inpdir = os.path.dirname(os.path.abspath(self._inputs[0]))
                if os.path.exists(inpdir) and os.path.isdir(inpdir):
                    for filename in reversed(sorted(os.listdir(inpdir))):
                        if filename.startswith(prefix):
                            self._add_vrm_thumbnail(gltf_node, os.path.join(inpdir, filename))
                            break

        return gltf_node

    def _make_vrm_material(self, material):
        vrm_material = {
            'floatProperties': {
                '_BlendMode': 0 if material.blend_method == 'OPAQUE' else 1,
                '_BumpScale': 1,
                '_CullMode': 2 if material.use_backface_culling else 0,
                '_Cutoff': material.alpha_threshold,
                '_DebugMode': 0,
                '_DstBlend': 0,
                '_IndirectLightIntensity': 0.1,
                '_LightColorAttenuation': 0,
                '_MToonVersion': 35,
                '_OutlineColorMode': 0,
                '_OutlineCullMode': 1,
                '_OutlineLightingMix': 1,
                '_OutlineScaledMaxDistance': 1,
                '_OutlineWidth': 0.5,
                '_OutlineWidthMode': 0,
                '_ReceiveShadowRate': 1,
                '_RimFresnelPower': 1,
                '_RimLift': 0,
                '_RimLightingMix': 0,
                '_ShadeShift': 0,
                '_ShadeToony': 0.9,
                '_ShadingGradeRate': 1,
                '_SrcBlend': 1,
                '_UvAnimRotation': 0,
                '_UvAnimScrollX': 0,
                '_UvAnimScrollY': 0,
                '_ZWrite': 1,
            },

            'keywordMap': {},
            'name': material.name,
            'renderQueue': 2000,
            'shader': 'VRM_USE_GLTFSHADER',
            'tagMap': {},
            'textureProperties': {},

            'vectorProperties': {
                '_BumpMap': [0, 0, 1, 1],
                '_Color': [1, 1, 1, 1],
                '_EmissionColor': [0, 0, 0, 1],
                '_EmissionMap': [0, 0, 1, 1],
                '_MainTex': [0, 0, 1, 1],
                '_OutlineColor': [0, 0, 0, 1],
                '_OutlineWidthTexture': [0, 0, 1, 1],
                '_ReceiveShadowTexture': [0, 0, 1, 1],
                '_RimColor': [0, 0, 0, 1],
                '_RimTexture': [0, 0, 1, 1],
                '_ShadeColor': [1, 1, 1, 1],
                '_ShadeTexture': [0, 0, 1, 1],
                '_ShadingGradeTexture': [0, 0, 1, 1],
                '_SphereAdd': [0, 0, 1, 1],
                '_UvAnimMaskTexture': [0, 0, 1, 1],
            },
        }

        return vrm_material

    def _make_vrm_blend_shape(self, name):
        """
        Standby expression:
        - Neutral

        Lip-sync:
        - A (aa)
        - I (ih)
        - U (ou)
        - E (e)
        - O (oh)

        Blink:
        - Blink
        - Blink_L
        - Blink_R

        Emotion:
        - Fun
        - Angry
        - Sorrow
        - Joy

        Eye control:
        - LookUp
        - LookDown
        - LookLeft
        - LookRight
        """

        dmta = bpy.context.scene.vrm_meta
        vrm_name = {
            # bawaan
            dmta.v_a : 'A',
            dmta.v_i : 'I',
            dmta.v_u : 'U',
            dmta.v_e : 'E',
            dmta.v_o : 'O',
            dmta.blink : 'Blink',
            dmta.blink_l : 'Blink_L',
            dmta.blink_r : 'Blink_R',
            # dari vrm documantion
            dmta.lookup : 'LookUp',
            dmta.lookdown : 'LookDown',
            dmta.lookleft : 'LookLeft',
            dmta.lookright : 'LookRight',
            # expresi
            dmta.joy : 'Joy',
            dmta.angry : 'Angry',
            dmta.sorrow : 'Sorrow',
            dmta.fun : 'Fun',
            # alis
            dmta.brows_up : 'Brows up',
            dmta.brows_down : 'Brows down',
        }.get(name, name)
        
        bin_bsk = {
            dmta.v_a : dmta.bin_v_a,
            dmta.v_i : dmta.bin_v_i,
            dmta.v_u : dmta.bin_v_u,
            dmta.v_e : dmta.bin_v_e,
            dmta.v_o : dmta.bin_v_o,
            dmta.blink : dmta.bin_blink,
            dmta.blink_l : dmta.bin_blink_l,
            dmta.blink_r : dmta.bin_blink_r,
            # dari vrm documantion
            dmta.lookup : dmta.bin_lookup,
            dmta.lookdown : dmta.bin_lookdown,
            dmta.lookleft : dmta.bin_lookleft,
            dmta.lookright : dmta.bin_lookright,
            # expresi
            dmta.joy : dmta.bin_joy,
            dmta.angry : dmta.bin_angry,
            dmta.sorrow : dmta.bin_sorrow,
            dmta.fun : dmta.bin_fun,
            # alis
            dmta.brows_up : dmta.bin_brows_up,
            dmta.brows_down : dmta.bin_brows_down,
        }.get(name, False)

        vrm_blend_shape = {
            'name': vrm_name,
            'presetName': vrm_name.lower(),
            'isBinary': bin_bsk, #False,
            'binds': [],  # ikat ke ID mesh dan ID blend shape dengan wight blend shape
            'materialValues': [],  # untuk mengkesampingkan nilai material
        }

        return vrm_blend_shape

    def convert(self):
        root, buffer_ = super().convert()

        for gltf_material_id, gltf_material in enumerate(root['materials']):
            material = bpy.data.materials[gltf_material['name']]
            vrm_material = self._make_vrm_material(material)

            if gltf_material['alphaMode'] == 'OPAQUE':
                vrm_material['tagMap']['RenderType'] = 'Opaque'
                vrm_material['shader'] = 'VRM/MToon'
            else:
                vrm_material['shader'] = 'VRM/UnlitCutout'

            if gltf_material['pbrMetallicRoughness'].get('baseColorTexture'):
                vrm_material['textureProperties']['_MainTex'] = gltf_material['pbrMetallicRoughness']['baseColorTexture']['index']

            root['extensions']['VRM']['materialProperties'].append(vrm_material)

        vrm_blend_shapes = {
            'Neutral': {
                'name': 'Neutral',
                'presetName': 'Neutral',
                'isBinary': False,
                'binds': [],
                'materialValues': [],
            }
        }
        for gltf_mesh_id, gltf_mesh in enumerate(root['meshes']):
            vrm_annotation = {
                'firstPersonFlag': 'Auto',
                'mesh': gltf_mesh_id,
            }
            root['extensions']['VRM']['firstPerson']['meshAnnotations'].append(vrm_annotation)

            for gltf_primitive_id, gltf_primitive in enumerate(gltf_mesh['primitives']):
                for sk_id, sk_name in enumerate(gltf_primitive['extras']['targetNames']):
                    if sk_name in vrm_blend_shapes:
                        vrm_blend_shape = vrm_blend_shapes[sk_name]
                    else:
                        vrm_blend_shape = self._make_vrm_blend_shape(sk_name)
                        vrm_blend_shapes[sk_name] = vrm_blend_shape

                    for vrm_bind in vrm_blend_shape['binds']:
                        if vrm_bind['mesh'] == gltf_mesh_id and vrm_bind['index'] == sk_id:
                            break
                    else:
                        vrm_bind = {
                            'mesh': gltf_mesh_id,
                            'index': sk_id,
                            'weight': 100,
                        }
                        vrm_blend_shape['binds'].append(vrm_bind)

        for vrm_blend_shape in vrm_blend_shapes.values():
            root['extensions']['VRM']['blendShapeMaster']['blendShapeGroups'].append(vrm_blend_shape)

        return root, buffer_
    
class VRMExporterOperator(bpy.types.Operator, ExportHelper):
    bl_idname = 'avatar.vrm'
    bl_label = 'Export VRM v0.0 (.vrm)'
    bl_description = 'Export VRM'
    bl_options = {'REGISTER', 'UNDO'}

    filename_ext = '.vrm'
    filter_glob: bpy.props.StringProperty(default='*.vrm', options={'HIDDEN'})

    def execute(self, context: bpy.types.Context):
        if not self.filepath:
            return {'CANCELLED'}
        
        dmta = bpy.context.scene.vrm_meta
        
        bpy.ops.obj.generate_mhv()
        bpy.ops.obj.cek_bsk()
        if dmta.amwsk_gagal == True:
            self.report({'ERROR'}, "Modifier cannot be applied to a mesh with shape keys, only 'armature' and 'collision' can")
            return {'CANCELLED'}
        if dmta.find_obj == False:
            self.report({'ERROR'}, "None Object was found! (Make sure Object is in the active collection)")
            return {'CANCELLED'}
        elif dmta.find_rig == False:
            self.report({'ERROR'}, "None Main Rig was found! (Make sure Object Armature for Main Rig is in the active collection)")
            return {'CANCELLED'}
        elif dmta.find_model == False:
            self.report({'ERROR'}, "None Object Main Model was found! (Make sure Object for Main Model is in the active collection)")
            return {'CANCELLED'}
        elif dmta.find_bone == False:
            pesan_salahnya = ("Object '%s' has some Required Bones missing!" % (dmta.rig.name))
            self.report({'ERROR'}, pesan_salahnya)
            return {'CANCELLED'}
        elif dmta.find_parent == False:
            pesan_salahnya = ("Object '%s' has some Bone Parent Required is missing or incorrect!" % (dmta.rig.name))
            self.report({'ERROR'}, pesan_salahnya)
            return {'CANCELLED'}
        else:
            dmta.ingat_undo = True
            print ("jalan")

        class Args(object):
            inputs = []
            output = self.filepath
            export = 'all'
            render = 'default'
            exec = None
            action = None
            speed = None
            scale = None
            merge = None
            keep = None
            no_extra_uv = None
            no_materials = None
            no_textures = None
            empty_textures = None
            set_origin = None
            normalize_weights = None


        bpy.context.window_manager.progress_begin(1, 100)
        args = Args()
        e = VRMExporter(args)
        out, buf = e.convert()

        e.write(out, args.output, is_binary=True)

        # re-open current file
#        bpy.ops.wm.open_mainfile(filepath=bpy.data.filepath)
        
#        bpy.ops.ed.undo()

        bpy.context.window_manager.progress_update(10)
        #if dmta.debug1 == False:
            #bpy.ops.obj.bckres()
        bpy.context.window_manager.progress_end()
        lapor = ("VRM saved in : %s" % (args.output))
        self.report({'INFO'}, lapor)
        
        if bpy.app.timers.is_registered(kembalikan):
            bpy.app.timers.unregister(kembalikan)
        bpy.app.timers.register(kembalikan, first_interval=0.2)

        return {"FINISHED"}

    def invoke(self, context, event):
        return cast(Set[str], ExportHelper.invoke(self, context, event))

    def draw(self, context):
        pass
    
#------------------------------------------------
def kembalikan():
    bpy.ops.ed.undo()
    bpy.app.timers.unregister(kembalikan)
    print()
    print("Done")
#------------------------------------------------
def update_type_jinggle(self, context):
    #bone = context.object.data.bones.active
    va = context.object.data
    #vb = context.object.pose.bones[bone.name]
    for bone in va.bones:
        if bone.select == True:
            vb = context.object.pose.bones[bone.name]
            if vb.vrmprop_aktif == 'Collider':
                hapus_type_spring(self, context, vb)
                add_type_collider(self, context, va, vb)
            elif vb.vrmprop_aktif == 'Spring':
                hapus_type_collider(self, context, va, vb)
                add_type_spring(self, context, vb)
            else:
                hapus_type_collider(self, context, va, vb)
                hapus_type_spring(self, context, vb)
    update_show_hit(self, context)
    update_colliders_hiden(self, context)
    update_colliders_all(self, context)
    return

def add_type_spring(self, context, vb):
    if not vb.vrmprop_spring_id == 'kdbaisi':
        id_spring = vb.vrmprop_spring_id
    else:
        angka = random.uniform(0, 100)
        id_spring = ("Preview_hit_%s%f" % (vb.name, angka))
        vb.vrmprop_spring_id = id_spring
    buat_spring_hit_Preview(self, context, id_spring, vb)
    #vb.vrmprop_show_hit = True
    
def add_type_collider(self, context, va, vb):
    if not vb.vrmprop_collider_id == 'kdbaisi':
        id = vb.vrmprop_collider_id
    else:
        angka = random.uniform(0, 100)
        id = ("%s%f" % (vb.name, angka))
        vb.vrmprop_collider_id = id
        vb.vrmprop_collider_name = vb.name
    if id not in [item.id for item in va.vrmprop_grub_collider]:
        cg = va.vrmprop_grub_collider.add()
        cg.name = vb.vrmprop_collider_name
        cg.id = id
    if not len(vb.vrmprop_collider) == 0:
        for item in vb.vrmprop_collider:
            if item.tampil not in [object.name for object in bpy.context.scene.objects]:
                id_empty = item.tampil
                obj = context.object
                radius = item.radius
                ro = item.rotasi_preview
                #loc = obj.matrix_world @ vb.head
                lx = item.origin[0] + item.offset[0]
                ly = item.origin[1] + item.offset[1]
                lz = item.origin[2] + item.offset[2]
                loc = (lx, ly, lz)
                buat_collider_Preview(self, context, id_empty, obj, vb, loc, ro, radius)
        
def hapus_type_spring(self, context, vb):
    id_spring = vb.vrmprop_spring_id
    hapus_spring_hit_Preview(self, context, id_spring)
    
def hapus_type_collider(self, context, va, vb):
    for i, item in enumerate(va.vrmprop_grub_collider):
        if item.get('id') == vb.vrmprop_collider_id:
            va.vrmprop_grub_collider.remove(i)
            break
    for item in vb.vrmprop_collider:
        id_empty = item.tampil
        hapus_collider_Preview(self, context, id_empty)

def update_collider_name(self, context):
    va = context.object.data
    for bone in va.bones:
        if bone.select == True:
            vb = context.object.pose.bones[bone.name]
            for item in va.vrmprop_grub_collider:
                if item.get('id') == vb.vrmprop_collider_id:
                    item.name = vb.vrmprop_collider_name
                    break
    update_colliders_all(self, context)
    return

def update_colliders_all(self, context):
    obj = context.object
    for bone in obj.pose.bones:
        if bone.vrmprop_aktif == 'Spring' and bone.vrmprop_use_colliders == True:
            #menambahkan colider yang tidak ada
            for item in obj.data.vrmprop_grub_collider:
                if item.id not in [item.id for item in bone.vrmprop_colliders]:
                    ad = bone.vrmprop_colliders.add()
                    ad.name = item.name
                    ad.id = item.id
                    #ad.aktif = True
        
            #menghapus colider yang tidak ada
            for i, item in reversed(list(enumerate(bone.vrmprop_colliders))):
                if item.id not in [item.id for item in obj.data.vrmprop_grub_collider]:
                    bone.vrmprop_colliders.remove(i)
        
            #update nama di collider
            for item in obj.data.vrmprop_grub_collider:
                item1 = item
                for item in bone.vrmprop_colliders:
                    item2 = item
                    if item2.id == item1.id:
                        item2.name = item1.name
    
def update_colliders(self, context):
    va = context.object.data
    for bone in va.bones:
        if bone.select == True:
            vb = context.object.pose.bones[bone.name]
            if vb.vrmprop_use_colliders == True:
                #menambahkan colider yang tidak ada
                for item in va.vrmprop_grub_collider:
                    if item.id not in [item.id for item in vb.vrmprop_colliders]:
                        ad = vb.vrmprop_colliders.add()
                        ad.name = item.name
                        ad.id = item.id
                        #ad.aktif = True
        
                #menghapus colider yang tidak ada
                for i, item in reversed(list(enumerate(vb.vrmprop_colliders))):
                    if item.id not in [item.id for item in va.vrmprop_grub_collider]:
                        vb.vrmprop_colliders.remove(i)
        
                #update nama di collider
                for item in va.vrmprop_grub_collider:
                    item1 = item
                    for item in vb.vrmprop_colliders:
                        item2 = item
                        if item2.id == item1.id:
                            item2.name = item1.name
    
def update_use_colliders(self, context):
    va = context.object.data
    for bone in va.bones:
        if bone.select == True:
            vb = context.object.pose.bones[bone.name]
            id_spring = vb.vrmprop_spring_id
            if vb.vrmprop_use_colliders == True:
                buat_spring_hit_Preview(self, context, id_spring, vb)
            else:
                hapus_spring_hit_Preview(self, context, id_spring)
    update_show_hit(self, context)
    update_colliders(self, context)
        
def update_radius(self, context):
    update_colliders(self, context)
    update_spring_hit_radius(self, context)
    
class collider_grub(bpy.types.PropertyGroup):
    name: bpy.props.StringProperty(name="Name", default="")
    id : bpy.props.StringProperty(name="ID", default="")
    
class jinggle_collider(bpy.types.PropertyGroup):
    name: bpy.props.StringProperty(name="Name", default="")
    radius: bpy.props.FloatProperty(name="Radius", default=1,  min= 0.01, step=5, subtype='DISTANCE', update = update_collider_radius)
    offset: bpy.props.FloatVectorProperty(name="Offset", default=(0.0, 0.0, 0.0), step=1, subtype='COORDINATES', update = update_collider_offset)
    mark: bpy.props.BoolProperty(name = "Mark", default = True)
    hiden: bpy.props.BoolProperty(name = "Show", default = False, update = update_colliders_hiden)
    rotasi_preview: bpy.props.FloatVectorProperty(name="Rotasi Preview", default=(0.0, 0.0, 0.0), step=10, subtype='EULER', update = update_collider_rotasi_preview)
    origin: bpy.props.FloatVectorProperty(name="Origin", default=(0.0, 0.0, 0.0))
    tampil: bpy.props.StringProperty(name="Tampil", default="")
    
class colliders(bpy.types.PropertyGroup):
    name: bpy.props.StringProperty(name="Name", default="")
    id : bpy.props.StringProperty(name="ID", default="")
    aktif : bpy.props.BoolProperty(name = "Use", default = True, update = update_colliders) 
    
class buat_jinggle_collider(bpy.types.Operator):
    bl_idname = "bone.buat_jinggle_collider"
    bl_label = "Add"
    bl_options = {'REGISTER', 'UNDO'}
    
    def execute(self, context):
        bone = context.object.data.bones.active
        if bone:
            obj = context.object
            vb = context.object.pose.bones[bone.name]
            angka = random.uniform(0, 100)
            id_empty = ("Preview_%s%f" % (vb.vrmprop_collider_name, angka))
            radius = 1
            ro = (0.0, 0.0, 0.0)
            loc = obj.matrix_world @ vb.head
            jc = vb.vrmprop_collider.add()
            jc.name = "data"
            jc.radius = radius
            jc.offset = (0.0, 0.0, 0.0)
            jc.rotasi_preview = ro
            jc.origin = loc
            jc.tampil = id_empty
            buat_collider_Preview(self, context, id_empty, obj, vb, loc, ro, radius)
            vb.vrmprop_collider_pilih = len(vb.vrmprop_collider)-1
        return {'FINISHED'}
    
class hapus_jinggle_collider(bpy.types.Operator):
    bl_idname = "bone.hapus_jinggle_collider"
    bl_label = "Remove"
    bl_options = {'REGISTER', 'UNDO'}
    
    def execute(self, context):
        bone = context.object.data.bones.active
        if bone:
            vb = context.object.pose.bones[bone.name]
            if not len(vb.vrmprop_collider) == 0:
                pilih = vb.vrmprop_collider_pilih
                id_empty = vb.vrmprop_collider[pilih].tampil
                hapus_collider_Preview(self, context, id_empty)
                vb.vrmprop_collider.remove(pilih)
                if pilih > len(vb.vrmprop_collider)-1 and not vb.vrmprop_collider_pilih == 0:
                    vb.vrmprop_collider_pilih = len(vb.vrmprop_collider)-1
            else:
                return {'CANCELLED'}
        return {'FINISHED'}
    
class dup_jinggle_collider(bpy.types.Operator):
    bl_idname = "bone.dup_jinggle_collider"
    bl_label = "Duplicate"
    bl_options = {'REGISTER', 'UNDO'}
    
    def execute(self, context):
        bone = context.object.data.bones.active
        if bone:
            vb = context.object.pose.bones[bone.name]
            pilih = vb.vrmprop_collider_pilih
            if not pilih > len(vb.vrmprop_collider)-1:
                obj = context.object
                angka = random.uniform(0, 100)
                id_empty = ("Preview_%s%f" % (vb.vrmprop_collider_name, angka))
                radius = vb.vrmprop_collider[pilih].radius
                ro = vb.vrmprop_collider[pilih].rotasi_preview
                ori = obj.matrix_world @ vb.head
                jc = vb.vrmprop_collider.add()
                jc.name = vb.vrmprop_collider[pilih].name
                jc.radius = radius
                jc.offset = vb.vrmprop_collider[pilih].offset
                jc.rotasi_preview = ro
                jc.origin = ori
                jc.tampil = id_empty
                loc = ori + vb.vrmprop_collider[pilih].offset
                buat_collider_Preview(self, context, id_empty, obj, vb, loc, ro, radius)
                vb.vrmprop_collider_pilih = len(vb.vrmprop_collider)-1
        return {'FINISHED'}

class add_multiply_data(bpy.types.Operator):
    bl_idname = "bone.add_multiply_data"
    bl_label = "Add multiply data"
    bl_options = {'REGISTER', 'UNDO'}
    
    name : bpy.props.StringProperty(name="Name", default="data")
    jumlah : bpy.props.IntProperty(name = "Amount", default = 1, min= 1)
    radius : bpy.props.FloatProperty(name="Radius", default=1,  min= 0.01, step=5, subtype='DISTANCE')
    offset_x : bpy.props.FloatProperty(name="X", default=0, step=10)
    offset_y : bpy.props.FloatProperty(name="Y", default=0, step=10)
    offset_z : bpy.props.FloatProperty(name="Z", default=0, step=10)
    operasi : bpy.props.BoolProperty(name = "Add (+) multiply", default = False)
    operasi_nilai_x : bpy.props.FloatProperty(name="X", default=0.1, step=10)
    operasi_nilai_y : bpy.props.FloatProperty(name="Y", default=0.1, step=10)
    operasi_nilai_z : bpy.props.FloatProperty(name="Z", default=0.1, step=10)

    def execute(self, context):
        obj = context.object
        bone = obj.data.bones.active
        vb = obj.pose.bones[bone.name]
        banyak = self.jumlah +1
        for step in range(banyak):
            if step == 0:
                continue
            else:
                namanya = ("%s%i" % (self.name, step))
                angka = random.uniform(0, 100)
                id_empty = ("Preview_%s%f" % (vb.vrmprop_collider_name, angka))
                if self.operasi == True:
                    atur_offset = step -1
                    if atur_offset == 0:
                        offset = (self.offset_x, self.offset_y, self.offset_z)
                    else:
                        ox = self.offset_x + (self.operasi_nilai_x*atur_offset)
                        oy = self.offset_y + (self.operasi_nilai_y*atur_offset)
                        oz = self.offset_z + (self.operasi_nilai_z*atur_offset)
                        offset = (ox, oy, oz)
                else:
                    offset = (self.offset_x, self.offset_y, self.offset_z)
                 
                radius = self.radius
                ro = (0.0, 0.0, 0.0)
                ori = obj.matrix_world @ vb.head
                loc = (
                    ori[0]+offset[0],
                    ori[1]+offset[1],
                    ori[2]+offset[2]
                    )
                jc = vb.vrmprop_collider.add()
                jc.name = namanya
                jc.radius = radius
                jc.offset = offset
                jc.rotasi_preview = ro
                jc.origin = ori
                jc.tampil = id_empty
                buat_collider_Preview(self, context, id_empty, obj, vb, loc, ro, radius)
        
        return {'FINISHED'}
    
    def invoke(self, context, event):
        return context.window_manager.invoke_props_dialog(self)
    
    def draw(self, context):
        layout = self.layout
        row = layout.row()
        row.prop(self, "name")
        row.prop(self, "jumlah")
        layout.prop(self, "radius")
        layout.label(text="Offset")
        row = layout.row()
        col = row.column()
        col.prop(self, "offset_x")
        col.prop(self, "offset_y")
        col.prop(self, "offset_z")
        col = row.column()
        col.label(text="")
        col.prop(self, "operasi")
        col.label(text="")
        col = row.column()
        col.enabled = self.operasi
        col.prop(self, "operasi_nilai_x")
        col.prop(self, "operasi_nilai_y")
        col.prop(self, "operasi_nilai_z")
        
class hapus_multiply_data(bpy.types.Operator):
    bl_idname = "bone.remove_multiply_data"
    bl_label = "Remove multiply data"
    bl_options = {'REGISTER', 'UNDO'}
    
    tipe : bpy.props.EnumProperty(
        name= "Remove type",
        items= [
            ('All', "All", "", "PANEL_CLOSE", 0),
            ('Mark', "Mark", "", "BOOKMARKS", 1)
        ]
    )

    def execute(self, context):
        obj = context.object
        bone = obj.data.bones.active
        vb = obj.pose.bones[bone.name]
        
        if self.tipe == 'Mark':
            for i, item in reversed(list(enumerate(vb.vrmprop_collider))):
                if item.mark == True:
                    id_empty = item.tampil
                    hapus_collider_Preview(self, context, id_empty)
                    vb.vrmprop_collider.remove(i)
        else:
            for i, item in reversed(list(enumerate(vb.vrmprop_collider))):
                id_empty = item.tampil
                hapus_collider_Preview(self, context, id_empty)
                vb.vrmprop_collider.remove(i)
                
        pilih = vb.vrmprop_collider_pilih
        if pilih > len(vb.vrmprop_collider)-1 and not vb.vrmprop_collider_pilih == 0:
            vb.vrmprop_collider_pilih = len(vb.vrmprop_collider)-1
            
        return {'FINISHED'}
    
    def invoke(self, context, event):
        return context.window_manager.invoke_props_dialog(self)
    
    def draw(self, context):
        obj = context.object
        bone = obj.data.bones.active
        vb = obj.pose.bones[bone.name]
        layout = self.layout
        layout.prop(self, "tipe")
        row = layout.row()
        if self.tipe == 'All':
            row.enabled = False
        else:
            row.enabled = True
        row.template_list("jinggle_collider_UI", "", vb, "vrmprop_collider", vb, "vrmprop_collider_pilih")
        col = row.column()
        col.operator("bone.mark_all_data", icon='BOOKMARKS')
        col.operator("bone.unmark_all_data", icon='CHECKBOX_DEHLT')
        col.operator("bone.balik_mark_all_data", icon='UV_SYNC_SELECT')
        col.separator()
        col.operator("bone.mark_show_data", icon='RESTRICT_VIEW_OFF')
        col.operator("bone.mark_hiden_data", icon='RESTRICT_VIEW_ON')
    
class mark_all_data(bpy.types.Operator):
    bl_idname = "bone.mark_all_data"
    bl_label = "Mark all"
    bl_options = {'REGISTER', 'UNDO'}
    
    def execute(self, context):
        bone = context.object.data.bones.active
        vb = context.object.pose.bones[bone.name]
        for item in vb.vrmprop_collider:
            item.mark = True
        return {'FINISHED'}
    
class unmark_all_data(bpy.types.Operator):
    bl_idname = "bone.unmark_all_data"
    bl_label = "Unmark all"
    bl_options = {'REGISTER', 'UNDO'}
    
    def execute(self, context):
        bone = context.object.data.bones.active
        vb = context.object.pose.bones[bone.name]
        for item in vb.vrmprop_collider:
            item.mark = False
        return {'FINISHED'}

class balik_mark_all_data(bpy.types.Operator):
    bl_idname = "bone.balik_mark_all_data"
    bl_label = "Invert mark all"
    bl_options = {'REGISTER', 'UNDO'}
    
    def execute(self, context):
        bone = context.object.data.bones.active
        vb = context.object.pose.bones[bone.name]
        for item in vb.vrmprop_collider:
            if item.mark == True:
                item.mark = False
            else:
                item.mark = True
        return {'FINISHED'}

class mark_show_data(bpy.types.Operator):
    bl_idname = "bone.mark_show_data"
    bl_label = "Mark show data"
    bl_options = {'REGISTER', 'UNDO'}
    
    def execute(self, context):
        bone = context.object.data.bones.active
        vb = context.object.pose.bones[bone.name]
        for item in vb.vrmprop_collider:
            if item.hiden == False:
                item.mark = True
            else:
                item.mark = False
        return {'FINISHED'}
    
class mark_hiden_data(bpy.types.Operator):
    bl_idname = "bone.mark_hiden_data"
    bl_label = "Mark hiden data"
    bl_options = {'REGISTER', 'UNDO'}
    
    def execute(self, context):
        bone = context.object.data.bones.active
        vb = context.object.pose.bones[bone.name]
        for item in vb.vrmprop_collider:
            if item.hiden == True:
                item.mark = True
            else:
                item.mark = False
        return {'FINISHED'}
    
class show_all_data(bpy.types.Operator):
    bl_idname = "bone.show_all_data"
    bl_label = "Show all"
    bl_options = {'REGISTER', 'UNDO'}
    
    def execute(self, context):
        bone = context.object.data.bones.active
        vb = context.object.pose.bones[bone.name]
        for item in vb.vrmprop_collider:
            item.hiden = False
        return {'FINISHED'}
    
class hiden_all_data(bpy.types.Operator):
    bl_idname = "bone.hiden_all_data"
    bl_label = "Hiden all"
    bl_options = {'REGISTER', 'UNDO'}
    
    def execute(self, context):
        bone = context.object.data.bones.active
        vb = context.object.pose.bones[bone.name]
        for item in vb.vrmprop_collider:
            item.hiden = True
        return {'FINISHED'}

class balik_all_data(bpy.types.Operator):
    bl_idname = "bone.balik_all_data"
    bl_label = "Invert show/hiden all"
    bl_options = {'REGISTER', 'UNDO'}
    
    def execute(self, context):
        bone = context.object.data.bones.active
        vb = context.object.pose.bones[bone.name]
        for item in vb.vrmprop_collider:
            if item.hiden == True:
                item.hiden = False
            else:
                item.hiden = True
        return {'FINISHED'}

class set_radius_data(bpy.types.Operator):
    bl_idname = "bone.set_radius_data"
    bl_label = "Set radius to multiply data"
    bl_options = {'REGISTER', 'UNDO'}
    
    radius : bpy.props.FloatProperty(name="Radius", default=1,  min= 0.01, step=5, subtype='DISTANCE')
    tipe : bpy.props.EnumProperty(
        name= "Set to",
        items= [
            ('All', "All Data", "", "PRESET", 0),
            ('Mark', "Mark Data", "", "BOOKMARKS", 1)
        ]
    )
    
    def execute(self, context):
        bone = context.object.data.bones.active
        vb = context.object.pose.bones[bone.name]
        awal_pilih = vb.vrmprop_collider_pilih

        if self.tipe == 'Mark':
            pilih = []
            for i, item in enumerate(vb.vrmprop_collider):
                if item.mark == True:
                    pilih.append(i)
            for item in pilih:
                vb.vrmprop_collider_pilih = item
                vb.vrmprop_collider[item].radius = self.radius
        else:
            data = len(vb.vrmprop_collider)
            for step in range(data):
                vb.vrmprop_collider_pilih = step
                vb.vrmprop_collider[step].radius = self.radius
                
        vb.vrmprop_collider_pilih = awal_pilih
        return {'FINISHED'}
    
    def invoke(self, context, event):
        bone = context.object.data.bones.active
        vb = context.object.pose.bones[bone.name]
        pilih = vb.vrmprop_collider_pilih
        self.radius = vb.vrmprop_collider[pilih].radius
        return context.window_manager.invoke_props_dialog(self)
    
    def draw(self, context):
        obj = context.object
        bone = obj.data.bones.active
        vb = obj.pose.bones[bone.name]
        layout = self.layout
        layout.prop(self, "radius")
        layout.prop(self, "tipe")
        row = layout.row()
        if self.tipe == 'All':
            row.enabled = False
        else:
            row.enabled = True
        row.template_list("jinggle_collider_UI", "", vb, "vrmprop_collider", vb, "vrmprop_collider_pilih")
        col = row.column()
        col.operator("bone.mark_all_data", icon='BOOKMARKS')
        col.operator("bone.unmark_all_data", icon='CHECKBOX_DEHLT')
        col.operator("bone.balik_mark_all_data", icon='UV_SYNC_SELECT')
        col.separator()
        col.operator("bone.mark_show_data", icon='RESTRICT_VIEW_OFF')
        col.operator("bone.mark_hiden_data", icon='RESTRICT_VIEW_ON')
    
class set_offset_data(bpy.types.Operator):
    bl_idname = "bone.set_offset_data"
    bl_label = "Set offset to multiply data"
    bl_options = {'REGISTER', 'UNDO'}
    
    tipe : bpy.props.EnumProperty(
        name= "Set to",
        items= [
            ('All', "All Data", "", "PRESET", 0),
            ('Mark', "Mark Data", "", "BOOKMARKS", 1)
        ]
    )
    offset_x : bpy.props.FloatProperty(name="X", default=0, step=10)
    offset_y : bpy.props.FloatProperty(name="Y", default=0, step=10)
    offset_z : bpy.props.FloatProperty(name="Z", default=0, step=10)
    ox : bpy.props.BoolProperty(name = "X", default = True)
    oy : bpy.props.BoolProperty(name = "Y", default = True)
    oz : bpy.props.BoolProperty(name = "Z", default = True)
    
    def execute(self, context):
        bone = context.object.data.bones.active
        vb = context.object.pose.bones[bone.name]
        awal_pilih = vb.vrmprop_collider_pilih
        
        if self.tipe == 'Mark':
            tanda = []
            for i, item in enumerate(vb.vrmprop_collider):
                if item.mark == True:
                    tanda.append(i)
            for item in tanda:
                self.atur(context, vb, item)
        else:
            data = len(vb.vrmprop_collider)
            for step in range(data):
                self.atur(context, vb, step)
            
        vb.vrmprop_collider_pilih = awal_pilih
        return {'FINISHED'}
    
    def atur(self, context, vb, pilih):
        vb.vrmprop_collider_pilih = pilih
        if self.ox:
            vb.vrmprop_collider[pilih].offset[0] = self.offset_x
        if self.oy:
            vb.vrmprop_collider[pilih].offset[1] = self.offset_y
        if self.oz:
            vb.vrmprop_collider[pilih].offset[2] = self.offset_z
        
    def invoke(self, context, event):
        return context.window_manager.invoke_props_dialog(self)
    
    def draw(self, context):
        obj = context.object
        bone = obj.data.bones.active
        vb = obj.pose.bones[bone.name]
        layout = self.layout
        layout.prop(self, "tipe")
        row = layout.row()
        if self.tipe == 'All':
            row.enabled = False
        else:
            row.enabled = True
        row.template_list("jinggle_collider_UI", "", vb, "vrmprop_collider", vb, "vrmprop_collider_pilih")
        col = row.column()
        col.operator("bone.mark_all_data", icon='BOOKMARKS')
        col.operator("bone.unmark_all_data", icon='CHECKBOX_DEHLT')
        col.operator("bone.balik_mark_all_data", icon='UV_SYNC_SELECT')
        col.separator()
        col.operator("bone.mark_show_data", icon='RESTRICT_VIEW_OFF')
        col.operator("bone.mark_hiden_data", icon='RESTRICT_VIEW_ON')
        layout.label(text="Offset")
        col = layout.column()
        row = col.row(align=True)
        row.prop(self, "ox", text="")
        isi = row.column()
        isi.enabled = self.ox
        isi.prop(self, "offset_x")
        row = col.row(align=True)
        row.prop(self, "oy", text="")
        isi = row.column()
        isi.enabled = self.oy
        isi.prop(self, "offset_y")
        row = col.row(align=True)
        row.prop(self, "oz", text="")
        isi = row.column()
        isi.enabled = self.oz
        isi.prop(self, "offset_z")
        
    
class aktif_all_colliders(bpy.types.Operator):
    bl_idname = "bone.aktif_all_colliders"
    bl_label = "Enabled all"
    bl_options = {'REGISTER', 'UNDO'}
    
    def execute(self, context):
        update_colliders(self, context)
        bone = context.object.data.bones.active
        vb = context.object.pose.bones[bone.name]
        for item in vb.vrmprop_colliders:
            item.aktif = True
        return {'FINISHED'}
        
class nonaktif_all_colliders(bpy.types.Operator):
    bl_idname = "bone.nonaktif_all_colliders"
    bl_label = "Disabled All"
    bl_options = {'REGISTER', 'UNDO'}
    
    def execute(self, context):
        update_colliders(self, context)
        bone = context.object.data.bones.active
        vb = context.object.pose.bones[bone.name]
        for item in vb.vrmprop_colliders:
            item.aktif = False
        return {'FINISHED'}
    
class balik_all_colliders(bpy.types.Operator):
    bl_idname = "bone.balik_all_colliders"
    bl_label = "Invert All Checkmark"
    bl_options = {'REGISTER', 'UNDO'}
    
    def execute(self, context):
        update_colliders(self, context)
        bone = context.object.data.bones.active
        vb = context.object.pose.bones[bone.name]
        for item in vb.vrmprop_colliders:
            if item.aktif == False:
                item.aktif = True
            else:
                item.aktif = False
        return {'FINISHED'}

class colliders_refresh(bpy.types.Operator):
    bl_idname = "bone.refresh_colliders"
    bl_label = "Refresh"
    
    def execute(self, context):
        update_colliders_all(self, context)
        return {'FINISHED'}


class jinggle_collider_UI(bpy.types.UIList):
    def draw_item(self, context, layout, data, item, icon, active_data, active_propname):
        slot = item
        if self.layout_type in {'DEFAULT', 'COMPACT'}:
            if item:
                row = layout.row(align=True)
                row.prop(item, "name", text="", emboss=False)
                if item.hiden == True:
                    row.prop(item, "hiden", text="", icon='RESTRICT_VIEW_ON', emboss=True)
                else:
                    row.prop(item, "hiden", text="", icon='RESTRICT_VIEW_OFF', emboss=True)
                if item.mark == True:
                    row.prop(item, "mark", text="", icon='BOOKMARKS', emboss=True)
                else:
                    row.prop(item, "mark", text="", icon='CHECKBOX_DEHLT', emboss=True)
            else:
                layout.label(text="", translate=False)

class colliders_UI(bpy.types.UIList):
    def draw_item(self, context, layout, data, item, icon, active_data, active_propname):
        slot = item
        if self.layout_type in {'DEFAULT', 'COMPACT'}:
            if item:
                row = layout.row(align=True)
                row.prop(item, "aktif", text="", emboss=True)
                row.label(text=item.name)
            else:
                layout.label(text="", translate=False)

class VRMPropBonePanel(bpy.types.Panel):
    bl_label = "Jingle VRM Bone"
    bl_idname = "VRM_bone"
    bl_space_type = 'PROPERTIES'
    bl_region_type = 'WINDOW'
    bl_context = "bone"
    bl_options = {'DEFAULT_CLOSED'}
    
    @classmethod
    def poll(cls, context):
        ob = context.object
        return ob and not ob.mode == 'EDIT' and context.bone
        
    def draw(self, context):
        bone = context.object.data.bones.active
        if bone:
        
            layout = self.layout
            
            layout.use_property_split = True
            layout.use_property_decorate = False

            va = context.object.data
            vb = context.object.pose.bones[bone.name]
        
            layout.prop(vb, "vrmprop_aktif")
            if vb.vrmprop_aktif == 'Spring':
                col = layout.column()
                col.prop(vb, "vrmprop_stiffness")
                col.prop(vb, "vrmprop_amplitude")
                col.prop(vb, "vrmprop_gravity")
                col.separator()
                col.use_property_split = False
                col.prop(vb, "vrmprop_use_colliders")
                col.use_property_split = True
                col = col.column()
                col.enabled = vb.vrmprop_use_colliders
                row = col.row()
                row.prop(vb, "vrmprop_radius")
                if vb.vrmprop_show_hit == False:
                    row.prop(vb, "vrmprop_show_hit", text="", icon='RESTRICT_VIEW_ON')
                else:
                    row.prop(vb, "vrmprop_show_hit", text="", icon='RESTRICT_VIEW_OFF')
                col.label(text="Colliders")
                col.use_property_split = False
                row = col.row()
                if vb.vrmprop_use_colliders == True:
                    row.template_list("colliders_UI", "", vb, "vrmprop_colliders", vb, "vrmprop_colliders_pilih")
                else:
                    box = row.box()
                    kotak = box.column()
                    kotak.scale_y = 0.9
                    kotak.label(text="")
                    kotak.label(text="Not use any", icon= 'INFO')
                    kotak.label(text="Jingle Collider Bone", icon= 'BLANK1')
                    kotak.label(text="")
                alat = row.column()
                alat.operator("bone.refresh_colliders", text = "", icon = 'FILE_REFRESH')
                alat.separator()
                alat.menu("Colliders_Menu", text="", icon='DOWNARROW_HLT')
                if len(vb.vrmprop_colliders) == 0 and vb.vrmprop_use_colliders == True:
                    row = col.row()
                    row.label(text="None Jingle Collider Bone", icon= 'INFO')
                
                #row = col.row()
                #row.template_list("jinggle_collider_UI", "", va, "vrmprop_grub_collider", vb, "vrmprop_colliders_pilih")
            elif vb.vrmprop_aktif == 'Collider':
                col = layout.column()
                col.prop(vb, "vrmprop_collider_name")
                #col.prop(vb, "vrmprop_collider_id")###########
                col.label(text="Collider Data")
                row = col.row()
                row.template_list("jinggle_collider_UI", "", vb, "vrmprop_collider", vb, "vrmprop_collider_pilih")
                col = row.column(align=True)
                col.operator("bone.buat_jinggle_collider", icon='ADD', text="")
                col.operator("bone.hapus_jinggle_collider", icon='REMOVE', text="")
                col.separator()
                tm = col.row()
                if len(vb.vrmprop_collider) == 0:
                    tm.enabled = False
                elif len(vb.vrmprop_collider) > 0:
                    tm.enabled = True
                tm.operator("bone.dup_jinggle_collider", icon='DUPLICATE', text="")
                col.separator()
                col.menu("Collider_Menu", text="", icon='MODIFIER')
                
                pilih = vb.vrmprop_collider_pilih
                
                if not pilih > len(vb.vrmprop_collider)-1:
                    tampil = vb.vrmprop_collider[pilih]
                    col = layout.column()
                    col.prop(tampil, "name")
                    col.prop(tampil, "radius")
                    col.prop(tampil, "offset")
                    col.label(text="Preview")
                    preview = col.row()
                    preview.enabled = False
                    preview.prop(tampil, "tampil", text="Object Preview")
                    col.prop(tampil, "rotasi_preview")
                    #col.prop(tampil, "origin")
                    #preview.prop(tampil, "hiden", text="", icon ='RESTRICT_VIEW_OFF')
                    
class ColliderMenu(bpy.types.Menu):
    bl_label = "ColliderMenu"
    bl_idname = "Collider_Menu"
    
    def draw(self, context):
        bone = context.object.data.bones.active
        vb = context.object.pose.bones[bone.name]
        if len(vb.vrmprop_collider) == 0:
            ada = False
        else:
            ada = True
        layout = self.layout
        col = layout.column()
        col.operator("bone.add_multiply_data", icon='DOCUMENTS')
        col1 = layout.column()
        col1.enabled = ada
        col1.operator("bone.remove_multiply_data", icon='TRASH')
        col1.separator()
        col1.operator("bone.mark_all_data", icon='BOOKMARKS')
        col1.operator("bone.unmark_all_data", icon='CHECKBOX_DEHLT')
        col1.operator("bone.balik_mark_all_data", icon='UV_SYNC_SELECT')
        col1.separator()
        col1.operator("bone.show_all_data", icon='RESTRICT_VIEW_OFF')
        col1.operator("bone.hiden_all_data", icon='RESTRICT_VIEW_ON')
        col1.operator("bone.balik_all_data", icon='UV_SYNC_SELECT')
        col1.separator()
        col1.operator("bone.set_radius_data", icon='CON_ROTLIKE')
        col1.operator("bone.set_offset_data", icon='CON_LOCLIKE')
    
class CollidersMenu(bpy.types.Menu):
    bl_label = "CollidersMenu"
    bl_idname = "Colliders_Menu"

    def draw(self, context):
        layout = self.layout
        layout.operator("bone.aktif_all_colliders", icon='CHECKBOX_HLT')
        layout.operator("bone.nonaktif_all_colliders", icon='CHECKBOX_DEHLT')
        layout.separator()
        layout.operator("bone.balik_all_colliders", icon='UV_SYNC_SELECT')
        
#-----------
def periksa_source(gambar, attribute):
    return hasattr(gambar, attribute)

def ganti_gambar(self, context):
    meta = context.scene.vrm_meta
    attribute = "source"
    if periksa_source(meta.gambar, attribute):
        if meta.gambar.source != 'FILE' :
            meta.gambar = None
    else :
        meta.gambar = None
    return None 

class cek_bsk(bpy.types.Operator):
    bl_idname = "obj.cek_bsk"
    bl_label = "Refresh"
    bl_options = {'REGISTER', 'UNDO'}
    
    def execute(self, context):
        update_bs(self,context)
        return {'FINISHED'}

class meta_props(bpy.types.PropertyGroup):
    #main meta
    nama : bpy.props.StringProperty(
        name= "Avatar Name",
        default= "Name"
    )
    gambar : bpy.props.PointerProperty(
        type=bpy.types.Image,
        name="Thumbnail",
        poll=lambda self,
        obj: obj.source == 'FILE',
        update= ganti_gambar
    )
    versi_model : bpy.props.StringProperty(
        name= "Version",
        default= "0.0.1"
    )
    author : bpy.props.StringProperty(
        name= "Author",
        default= "Your Name"
    )
    contact : bpy.props.StringProperty(
        name= "Contact Information",
        default= "Your Contact"
    )
    reference : bpy.props.StringProperty(
        name= "Reference",
        default= "Reference"
    )
    alloweduser : bpy.props.EnumProperty(
        name= "Allowed User",
        items= [
            ('OnlyAuthor', "Only Author", ""),
            ('ExplicitlyLicensedPerson', "Explicitly Licensed Person", ""),
            ('Everyone', "Everyone", "")
        ]
    )
    violentussage : bpy.props.EnumProperty(
        name= "Violent Ussage",
        items= [
            ('Disallow', "Disallow", ""),
            ('Allow', "Allow", "")
        ]
    )
    sexualussage : bpy.props.EnumProperty(
        name= "Sexual Ussage",
        items= [
            ('Disallow', "Disallow", "")
        ]
    )
    commercial : bpy.props.EnumProperty(
        name= "Commercial Ussage",
        items= [
            ('Disallow', "Disallow", ""),
            ('Allow', "Allow", "")
        ]
    )
    otherPermissionUrl : bpy.props.StringProperty(
        name= "Other Permission Url",
        default= ""
    )
    license : bpy.props.EnumProperty(
        name= "License",
        items= [
            ('Redistribution_Prohibited', "Redistribution Disallow", ""),
            ('CC0', "Public Domain (CC0)", ""),
            ('CC_BY', "CC BY", ""),
            ('CC_BY_NC', "CC BY NC", ""),
            ('CC_BY_SA', "CC BY SA", ""),
            ('CC_BY_ND', "CC BY ND", ""),
            ('CC_BY_NC_SA', "CC BY NC SA", ""),
            ('CC_BY_NC_ND', "CC BY NC ND", ""),
            ('Other', "Other", ""),
        ]
    )
    licenseurl : bpy.props.StringProperty(
        name= "License Url",
        default= "http://www.exampel.com"
    )
    #blend shape meta
    joy : bpy.props.StringProperty(
        name= "Joy",
        default= "",
        update = update_bs
    )
    angry : bpy.props.StringProperty(
        name= "Angry",
        default= "",
        update = update_bs
    )
    sorrow : bpy.props.StringProperty(
        name= "Sorrow",
        default= "",
        update = update_bs
    )
    fun : bpy.props.StringProperty(
        name= "Fun",
        default= "",
        update = update_bs
    )
    blink : bpy.props.StringProperty(
        name= "Blink All",
        default= "",
        update = update_bs
    )
    blink_l : bpy.props.StringProperty(
        name= "Blink Left",
        default= "",
        update = update_bs
    )
    blink_r : bpy.props.StringProperty(
        name= "Blink Right",
        default= "",
        update = update_bs
    )
    brows_up : bpy.props.StringProperty(
        name= "Brows Up",
        default= "",
        update = update_bs
    )
    brows_down : bpy.props.StringProperty(
        name= "Brows Down",
        default= "",
        update = update_bs
    )
    v_a : bpy.props.StringProperty(
        name= "A",
        default= "",
        update = update_bs
    )
    v_i : bpy.props.StringProperty(
        name= "I",
        default= "",
        update = update_bs
    )
    v_u : bpy.props.StringProperty(
        name= "U",
        default= "",
        update = update_bs
    )
    v_e : bpy.props.StringProperty(
        name= "E",
        default= "",
        update = update_bs
    )
    v_o : bpy.props.StringProperty(
        name= "O",
        default= "",
        update = update_bs
    )
    lookup : bpy.props.StringProperty(
        name= "Look Up",
        default= "",
        update = update_bs
    )
    lookdown : bpy.props.StringProperty(
        name= "Look Down",
        default= "",
        update = update_bs
    )
    lookleft : bpy.props.StringProperty(
        name= "Look Left",
        default= "",
        update = update_bs
    )
    lookright : bpy.props.StringProperty(
        name= "Look Right",
        default= "",
        update = update_bs
    )
    looktype : bpy.props.EnumProperty(
        name= "Look At Type",
        update = update_bs,
        items= [
            ('Bone', "Bone", ""),
            ('BlendShape', "Blend Shape", "")
        ]
    )
    #Biner shape key
    bin_joy: bpy.props.BoolProperty(
        name = "Set Blend Shape as Biner",
        default = False,
        update = update_bs
    )
    bin_angry: bpy.props.BoolProperty(
        name = "Set Blend Shape as Biner",
        default = False,
        update = update_bs
    )
    bin_sorrow: bpy.props.BoolProperty(
        name = "Set Blend Shape as Biner",
        default = False,
        update = update_bs
    )
    bin_fun: bpy.props.BoolProperty(
        name = "Set Blend Shape as Biner",
        default = False,
        update = update_bs
    )
    bin_blink: bpy.props.BoolProperty(
        name = "Set Blend Shape as Biner",
        default = False,
        update = update_bs
    )
    bin_blink_l: bpy.props.BoolProperty(
        name = "Set Blend Shape as Biner",
        default = False,
        update = update_bs
    )
    bin_blink_r: bpy.props.BoolProperty(
        name = "Set Blend Shape as Biner",
        default = False,
        update = update_bs
    )
    bin_brows_up: bpy.props.BoolProperty(
        name = "Set Blend Shape as Biner",
        default = False,
        update = update_bs
    )
    bin_brows_down: bpy.props.BoolProperty(
        name = "Set Blend Shape as Biner",
        default = False,
        update = update_bs
    )
    bin_v_a: bpy.props.BoolProperty(
        name = "Set Blend Shape as Biner",
        default = False,
        update = update_bs
    )
    bin_v_i: bpy.props.BoolProperty(
        name = "Set Blend Shape as Biner",
        default = False,
        update = update_bs
    )
    bin_v_u: bpy.props.BoolProperty(
        name = "Set Blend Shape as Biner",
        default = False,
        update = update_bs
    )
    bin_v_e: bpy.props.BoolProperty(
        name = "Set Blend Shape as Biner",
        default = False,
        update = update_bs
    )
    bin_v_o: bpy.props.BoolProperty(
        name = "Set Blend Shape as Biner",
        default = False,
        update = update_bs
    )
    bin_lookup: bpy.props.BoolProperty(
        name = "Set Blend Shape as Biner",
        default = False,
        update = update_bs
    )
    bin_lookdown: bpy.props.BoolProperty(
        name = "Set Blend Shape as Biner",
        default = False,
        update = update_bs
    )
    bin_lookleft: bpy.props.BoolProperty(
        name = "Set Blend Shape as Biner",
        default = False,
        update = update_bs
    )
    bin_lookright: bpy.props.BoolProperty(
        name = "Set Blend Shape as Biner",
        default = False,
        update = update_bs
    )
    #model
    rig : bpy.props.PointerProperty(
        type=bpy.types.Object,
        name="Rig Main",
        update = update_rig_main,
        poll=lambda self, 
        obj: obj.type == 'ARMATURE'
    )
    model : bpy.props.PointerProperty(
        type=bpy.types.Object,
        name="Mesh Main Model",
        update = update_bs,
        poll=lambda self, 
        obj: obj.type == 'MESH'
    )
    armstretch : bpy.props.FloatProperty(
        name= "Stretch", 
        default= 0.0, 
        step= 1
    )
    legstretch : bpy.props.FloatProperty(
        name= "Stretch", 
        default= 0.0, 
        step= 1
    )
    upperarmtwist : bpy.props.FloatProperty(
        name= "Upper Twist", 
        default= 0.0, 
        min= -360.0,
        max= 360.0,
        step= 1
    )
    lowerarmtwist : bpy.props.FloatProperty(
        name= "Lower Twist", 
        default= -25.0, 
        min= -360.0,
        max= 360.0,
        step= 1
    )
    upperlegtwist : bpy.props.FloatProperty(
        name= "Upper Twist", 
        default= 0.0, 
        min= -360.0,
        max= 360.0,
        step= 1
    )
    lowerlegtwist : bpy.props.FloatProperty(
        name= "lower Twist", 
        default= 0.0, 
        min= -360.0,
        max= 360.0,
        step= 1
    )
    feetspacing : bpy.props.FloatProperty(
        name= "Feet Spacing", 
        default= 0.0, 
        step= 1
    )
    translationdof: bpy.props.BoolProperty(
        name = "Translation DoF",
        default = False
    )
    #find
    find_obj: bpy.props.BoolProperty(
        name = "find",
        default = False
    )
    find_rig: bpy.props.BoolProperty(
        name = "find",
        default = False
    )
    find_model: bpy.props.BoolProperty(
        name = "find",
        default = False
    )
    amwsk_gagal: bpy.props.BoolProperty(
        name = "find",
        default = False
    )
    find_bone: bpy.props.BoolProperty(
        name = "find",
        default = False
    )
    find_parent: bpy.props.BoolProperty(
        name = "find",
        default = False
    )
    #Remember to undo
    ingat_undo: bpy.props.BoolProperty(
        name = "ingat undo",
        default = False
    )
    #Debung
    debug1: bpy.props.BoolProperty(
        name = "Debug",
        default = False
    )
    debug2: bpy.props.BoolProperty(
        name = "Debug",
        default = False
    )
    
class VRM_Tool_Panel(bpy.types.Panel):
    bl_label = "VRM Tool"
    bl_idname = "VRM_Panel"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = 'VRM Tool'
    
    def draw(self, context):
        layout = self.layout
        scene = context.scene
        obj = context.object
        meta = scene.vrm_meta
        
        layout.use_property_split = True
        layout.use_property_decorate = False
        
        #box = layout.box()
        #kotak = box.column()
        #kotak.scale_y = 0.7
        #kotak.label(text="Tutorial", icon= 'INFO') #tambahkan tombol menuju tutorial
        
#------------------Debug layout            
        #row = layout.row()
        #layout.prop(meta, "debug1")
        #layout.prop(meta, "find_bone")
        #layout.operator("obj.info_masalah_rig")
        #layout.operator("obj.cek_rig")
        #layout.operator("obj.generate_mhv")
        #layout.operator("obj.cek_bsk")
        #layout.prop(meta, "upperarmtwist")
        #layout.prop(meta, "lowerarmtwist")
        #layout.operator("obj.dub_hid")
        #layout.operator("obj.dubck")
        #layout.operator("obj.bckres")
        
#------------------Debug layout
    
class VRM_Generator_Panel(bpy.types.Panel):
    bl_label = "Model and Armature"
    bl_idname = "VRM_Panel_generate"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_parent_id = "VRM_Panel"
    bl_options = {'DEFAULT_CLOSED'}
    
    def draw(self, context):
        layout = self.layout
        scene = context.scene
        obj = context.object
        meta = scene.vrm_meta
        
        layout.use_property_split = True
        layout.use_property_decorate = False
        
        layout.label(text="Armature", icon='POSE_HLT')
        layout.operator("obj.generate_rig", icon= 'ADD')
        layout.label(text="Model", icon='MESH_CUBE')
        layout.operator("wm.obj_import",text = "Import .obj (blender importer)", icon= 'IMPORT')
        layout.operator("import_scene.vrm",text = "Import .vrm", icon= 'IMPORT')
    
class VRM_Export_Panel(bpy.types.Panel):
    bl_label = "VRM Export"
    bl_idname = "VRM_Panel_export"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_parent_id = "VRM_Panel"
     
    def draw(self, context):
        layout = self.layout
        scene = context.scene
        obj = context.object
        meta = scene.vrm_meta
        
        layout.use_property_split = True
        layout.use_property_decorate = False
        
        bisa = False
        
        if meta.model and meta.rig :
            bisa = True
        else :
            bisa = False
        
        col = layout.column()
        col.enabled = bisa
        col.operator("avatar.vrm")
        if meta.ingat_undo:
            box = col.box()
            box.alert = True
            kotak = box.column()
            kotak.scale_y = 0.7
            kotak.label(text="Warning !", icon= 'ERROR')
            kotak.label(text="Please undo or ctrl + z", icon= 'BLANK1')
            kotak.label(text="Then try again", icon= 'BLANK1')
        
        row = layout.row(align=True)
        if meta.rig :
            if meta.find_bone and meta.find_parent:
                row.prop_search(meta, "rig", scene, "objects", icon= 'POSE_HLT')
            else:
                row.prop_search(meta, "rig", scene, "objects", icon= 'POSE_HLT')
                per = row.column()
                per.alert = True
                per.operator("obj.info_masalah_rig", text= '', icon= 'ERROR')
        else:
            row.prop_search(meta, "rig", scene, "objects", icon= 'POSE_HLT')
            
        row = layout.row()
        split = layout.split()
        col = split.column()
        col.prop_search(meta, "model", scene, "objects", icon= 'MESH_DATA')
        
        row = layout.row()
        layout.label(text="Meta Data", icon='MENU_PANEL')
        
        split = layout.split()
        col = split.column()
        box = col.box()
        kotak = box.column()
        kotak.scale_y = 0.9
        kotak.label(text="Thumbnail")
        kotak.template_ID(meta, "gambar", open="image.open")
                
        split = layout.split()
        col = split.column()
        col.prop(meta, "nama")
        col.prop(meta, "versi_model")
        col.prop(meta, "author")
        col.prop(meta, "contact")
        col.prop(meta, "reference")
        col.prop(meta, "alloweduser")
        col.prop(meta, "violentussage")
        col.prop(meta, "sexualussage")
        col.prop(meta, "commercial")
        col.prop(meta, "otherPermissionUrl")
        col.prop(meta, "license")
        col.prop(meta, "licenseurl")
            
class VRM_humdat_Panel(bpy.types.Panel):
    bl_label = "Humanoid Data"
    bl_idname = "humdat_Panel"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_parent_id = "VRM_Panel_export"
    
    def draw(self, context):
        layout = self.layout
        scene = context.scene
        obj = context.object
        meta = scene.vrm_meta
        
        layout.use_property_split = True
        layout.use_property_decorate = False
        
        layout.label(text="Arm Bone")
        col = layout.column()
        col.prop(meta, "upperarmtwist")
        col.prop(meta, "lowerarmtwist")
        col.prop(meta, "armstretch")
        
        layout.label(text="Leg Bone")
        col = layout.column()
        col.prop(meta, "upperlegtwist")
        col.prop(meta, "lowerlegtwist")
        col.prop(meta, "legstretch")
        col.prop(meta, "feetspacing")
        
        layout.label(text="Translation")
        col = layout.column()
        col.prop(meta, "translationdof")

class VRM_BS_Panel(bpy.types.Panel):
    bl_label = "Main Blend Shape"
    bl_idname = "BS_Panel"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_parent_id = "VRM_Panel_export"
      
    def draw(self, context):
        global bsk_ada
        global bsk_hilang
        layout = self.layout
        scene = context.scene
        obj = context.object
        meta = scene.vrm_meta
        
        
        layout.use_property_split = True
        layout.use_property_decorate = False
        
        if meta.model == None :
            layout.label(text="Please select the mesh main model", icon='ERROR')
        else : 
            if meta.model.data.shape_keys == None:
                layout.label(text="None Shape Key was found", icon='ERROR')
                layout.operator("obj.generate_bsk")
            else : 
                col = layout.column()
                col.operator("obj.cek_bsk", icon= 'FILE_REFRESH')
                if not bsk_hilang == []:
                    box = col.box()
                    box.alert = True
                    kotak = box.column()
                    kotak.scale_y = 0.9
                    kotak.label(text="Warning", icon='ERROR')
                    
                    jumlah_hilang = len(bsk_hilang)
                    if jumlah_hilang > 0:
                        mis1 = ("Mising Shape Keys: %s" % (bsk_hilang[0]))
                        kotak.label(text= mis1, icon='BLANK1')
                    if jumlah_hilang > 1:
                        mis2 = ("Mising Shape Keys: %s" % (bsk_hilang[1]))
                        kotak.label(text= mis2, icon='BLANK1')
                    if jumlah_hilang > 2:
                        mis2 = ("Mising Shape Keys: %s" % (bsk_hilang[2]))
                        kotak.label(text= mis2, icon='BLANK1')
                box = col.box()
                kotak = box.column()
                kotak.scale_y = 0.9
                kotak.label(text="Tips: ", icon='QUESTION')
                kotak.label(text="Make sure all name in", icon='BLANK1')
                kotak.label(text="Shape Keys below is correct", icon='BLANK1')
                
                basis_standby = meta.model.data.shape_keys.key_blocks[0]
                col.label(text="Standby(Neutral)")
                col.label(text="(Automatically selects first Shape Key)")
                col = layout.column()
                col.enabled = False
                col.prop(basis_standby, "name", text= "", icon='SHAPEKEY_DATA')
        
class BS_expresion_Panel(bpy.types.Panel):
    bl_label = "Expresion"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_parent_id = "BS_Panel"
    bl_options = {'DEFAULT_CLOSED'}
      
    def draw(self, context):
        global bsk_ada
        layout = self.layout
        scene = context.scene
        obj = context.object
        meta = scene.vrm_meta
        
        layout.use_property_split = True
        layout.use_property_decorate = False
        
        if meta.model and meta.model.data.shape_keys:
            split = layout.split()
            col = split.column()
            
            row = col.row(align=True)
            row.prop_search(meta, "joy", meta.model.data.shape_keys, "key_blocks")
            row.prop(meta, "bin_joy", text= "", icon= 'IPO_CONSTANT')
            dobel1 = bsk_ada.count(meta.joy)
            if dobel1 > 1:
                sama1 = ("'%s' has selected in other" % (meta.joy))
                col.label(text=sama1, icon= 'ERROR')
                
            row = col.row(align=True)
            row.prop_search(meta, "angry", meta.model.data.shape_keys, "key_blocks")
            row.prop(meta, "bin_angry", text= "", icon= 'IPO_CONSTANT')
            dobel2 = bsk_ada.count(meta.angry)
            if dobel2 > 1:
                sama2 = ("'%s' has selected in other" % (meta.angry))
                col.label(text=sama2, icon= 'ERROR')
                
            row = col.row(align=True)
            row.prop_search(meta, "sorrow", meta.model.data.shape_keys, "key_blocks")
            row.prop(meta, "bin_sorrow", text= "", icon= 'IPO_CONSTANT')
            dobel3 = bsk_ada.count(meta.sorrow)
            if dobel3 > 1:
                sama3 = ("'%s' has selected in other" % (meta.sorrow))
                col.label(text=sama3, icon= 'ERROR')
                
            row = col.row(align=True)
            row.prop_search(meta, "fun", meta.model.data.shape_keys, "key_blocks")
            row.prop(meta, "bin_fun", text= "", icon= 'IPO_CONSTANT')
            dobel4 = bsk_ada.count(meta.fun)
            if dobel4 > 1:
                sama4 = ("'%s' has selected in other" % (meta.fun))
                col.label(text=sama4, icon= 'ERROR')
                
            row = col.row(align=True)
            row.prop_search(meta, "blink", meta.model.data.shape_keys, "key_blocks")
            row.prop(meta, "bin_blink", text= "", icon= 'IPO_CONSTANT')
            dobel5 = bsk_ada.count(meta.blink)
            if dobel5 > 1:
                sama5 = ("'%s' has selected in other" % (meta.blink))
                col.label(text=sama5, icon= 'ERROR')
                
            row = col.row(align=True)
            row.prop_search(meta, "blink_l", meta.model.data.shape_keys, "key_blocks")
            row.prop(meta, "bin_blink_l", text= "", icon= 'IPO_CONSTANT')
            dobel6 = bsk_ada.count(meta.blink_l)
            if dobel6 > 1:
                sama6 = ("'%s' has selected in other" % (meta.blink_l))
                col.label(text=sama6, icon= 'ERROR')
                
            row = col.row(align=True)
            row.prop_search(meta, "blink_r", meta.model.data.shape_keys, "key_blocks")
            row.prop(meta, "bin_blink_r", text= "", icon= 'IPO_CONSTANT')
            dobel7 = bsk_ada.count(meta.blink_r)
            if dobel7 > 1:
                sama7 = ("'%s' has selected in other" % (meta.blink_r))
                col.label(text=sama7, icon= 'ERROR')
                
            row = col.row(align=True)
            row.prop_search(meta, "brows_up", meta.model.data.shape_keys, "key_blocks")
            row.prop(meta, "bin_brows_up", text= "", icon= 'IPO_CONSTANT')
            dobel8 = bsk_ada.count(meta.brows_up)
            if dobel8 > 1:
                sama8 = ("'%s' has selected in other" % (meta.brows_up))
                col.label(text=sama8, icon= 'ERROR')
                
            row = col.row(align=True)
            row.prop_search(meta, "brows_down", meta.model.data.shape_keys, "key_blocks")
            row.prop(meta, "bin_brows_down", text= "", icon= 'IPO_CONSTANT')
            dobel9 = bsk_ada.count(meta.brows_down)
            if dobel9 > 1:
                sama9 = ("'%s' has selected in other" % (meta.brows_down))
                col.label(text=sama9, icon= 'ERROR')
        
class BS_look_Panel(bpy.types.Panel):
    bl_label = "Look At"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_parent_id = "BS_Panel"
    bl_options = {'DEFAULT_CLOSED'}
      
    def draw(self, context):
        global bsk_ada
        layout = self.layout
        scene = context.scene
        obj = context.object
        meta = scene.vrm_meta
        
        layout.use_property_split = True
        layout.use_property_decorate = False
        
        if meta.model and meta.model.data.shape_keys:
            split = layout.split()
            col = split.column()
            col.prop(meta, "looktype")
        
            if meta.looktype == 'BlendShape' :
                
                row = col.row(align=True)
                row.prop_search(meta, "lookup", meta.model.data.shape_keys, "key_blocks")
                row.prop(meta, "bin_lookup", text= "", icon= 'IPO_CONSTANT')
                dobel1_1 = bsk_ada.count(meta.lookup)
                if dobel1_1 > 1:
                    sama1_1 = ("'%s' has selected in other" % (meta.lookup))
                    col.label(text=sama1_1, icon= 'ERROR')
                
                row = col.row(align=True)
                row.prop_search(meta, "lookdown", meta.model.data.shape_keys, "key_blocks")
                row.prop(meta, "bin_lookdown", text= "", icon= 'IPO_CONSTANT')
                dobel1_2 = bsk_ada.count(meta.lookdown)
                if dobel1_2 > 1:
                    sama1_2 = ("'%s' has selected in other" % (meta.lookdown))
                    col.label(text=sama1_2, icon= 'ERROR')
                
                row = col.row(align=True)
                row.prop_search(meta, "lookleft", meta.model.data.shape_keys, "key_blocks")
                row.prop(meta, "bin_lookleft", text= "", icon= 'IPO_CONSTANT')
                dobel1_3 = bsk_ada.count(meta.lookleft)
                if dobel1_3 > 1:
                    sama1_3 = ("'%s' has selected in other" % (meta.lookleft))
                    col.label(text=sama1_3, icon= 'ERROR')
                
                row = col.row(align=True)
                row.prop_search(meta, "lookright", meta.model.data.shape_keys, "key_blocks")
                row.prop(meta, "bin_lookright", text= "", icon= 'IPO_CONSTANT')
                dobel1_4 = bsk_ada.count(meta.lookright)
                if dobel1_4 > 1:
                    sama1_4 = ("'%s' has selected in other" % (meta.lookright))
                    col.label(text=sama1_4, icon= 'ERROR')
            
class BS_mouth_Panel(bpy.types.Panel):
    bl_label = "Mouth Lip-sync"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_parent_id = "BS_Panel"
    bl_options = {'DEFAULT_CLOSED'}
      
    def draw(self, context):
        global bsk_ada
        layout = self.layout
        scene = context.scene
        obj = context.object
        meta = scene.vrm_meta
        
        layout.use_property_split = True
        layout.use_property_decorate = False
        
        if meta.model and meta.model.data.shape_keys:
            split = layout.split()
            col = split.column()
            
            row = col.row(align=True)
            row.prop_search(meta, "v_a", meta.model.data.shape_keys, "key_blocks")
            row.prop(meta, "bin_v_a", text= "", icon= 'IPO_CONSTANT')
            dobel2_1 = bsk_ada.count(meta.v_a)
            if dobel2_1 > 1:
                sama2_1 = ("'%s' has selected in other" % (meta.v_a))
                col.label(text=sama2_1, icon= 'ERROR')
                    
            row = col.row(align=True)
            row.prop_search(meta, "v_i", meta.model.data.shape_keys, "key_blocks")
            row.prop(meta, "bin_v_i", text= "", icon= 'IPO_CONSTANT')
            dobel2_2 = bsk_ada.count(meta.v_i)
            if dobel2_2 > 1:
                sama2_2 = ("'%s' has selected in other" % (meta.v_i))
                col.label(text=sama2_2, icon= 'ERROR')
                
            row = col.row(align=True)
            row.prop_search(meta, "v_u", meta.model.data.shape_keys, "key_blocks")
            row.prop(meta, "bin_v_u", text= "", icon= 'IPO_CONSTANT')
            dobel2_3 = bsk_ada.count(meta.v_u)
            if dobel2_3 > 1:
                sama2_3 = ("'%s' has selected in other" % (meta.v_u))
                col.label(text=sama2_3, icon= 'ERROR')
            
            row = col.row(align=True)
            row.prop_search(meta, "v_e", meta.model.data.shape_keys, "key_blocks")
            row.prop(meta, "bin_v_e", text= "", icon= 'IPO_CONSTANT')
            dobel2_4 = bsk_ada.count(meta.v_e)
            if dobel2_4 > 1:
                sama2_4 = ("'%s' has selected in other" % (meta.v_e))
                col.label(text=sama2_4, icon= 'ERROR')
            
            row = col.row(align=True)
            row.prop_search(meta, "v_o", meta.model.data.shape_keys, "key_blocks")
            row.prop(meta, "bin_v_o", text= "", icon= 'IPO_CONSTANT')
            dobel2_5 = bsk_ada.count(meta.v_o)
            if dobel2_5 > 1:
                sama2_5 = ("'%s' has selected in other" % (meta.v_o))
                col.label(text=sama2_5, icon= 'ERROR')

classes = [
    meta_props,
    cek_bsk,
    collider_grub,
    jinggle_collider,
    colliders,
    buat_jinggle_collider,
    hapus_jinggle_collider,
    dup_jinggle_collider,
    colliders_refresh,
    add_multiply_data,
    hapus_multiply_data,
    mark_all_data,
    unmark_all_data,
    balik_mark_all_data,
    mark_show_data,
    mark_hiden_data,
    show_all_data,
    hiden_all_data,
    balik_all_data,
    set_radius_data,
    set_offset_data,
    aktif_all_colliders,
    nonaktif_all_colliders,
    balik_all_colliders,
    jinggle_collider_UI,
    colliders_UI,
    VRM_Tool_Panel,
    VRM_Generator_Panel,
    VRM_Export_Panel,
    VRMExporterOperator,
    CollidersMenu,
    ColliderMenu,
    VRMPropBonePanel,
    VRM_humdat_Panel,
    VRM_BS_Panel,
    BS_expresion_Panel,
    BS_look_Panel,
    BS_mouth_Panel
]

def register():
    for cls in classes:
        bpy.utils.register_class(cls)
        
        bpy.types.Scene.vrm_meta = bpy.props.PointerProperty(type= meta_props)
        
    bpy.types.PoseBone.vrmprop_aktif = bpy.props.EnumProperty(
        name= "Jingle Type",
        items= [
            ('Disable', "None", ""),
            ('Spring', "Spring", ""),
            ('Collider', "Collider", "")
        ],
        update = update_type_jinggle,
    )
    bpy.types.PoseBone.vrmprop_stiffness = bpy.props.FloatProperty(
        name = "Stiffness",
        default = 0.06,
        min= 0,
        step=1,
        update = update_colliders
    )
    bpy.types.PoseBone.vrmprop_amplitude = bpy.props.FloatProperty(
        name = "Amplitude",
        default = 0.03,
        min= 0,
        step=1,
        update = update_colliders
    )
    bpy.types.PoseBone.vrmprop_gravity = bpy.props.FloatProperty(
        name = "gravity",
        default = 1.0,
        step=10,
        update = update_colliders
    )
    bpy.types.PoseBone.vrmprop_use_colliders = bpy.props.BoolProperty(
        name = "Use Colliders", 
        default = False,
        update = update_use_colliders
    )
    bpy.types.PoseBone.vrmprop_radius = bpy.props.FloatProperty(
        name = "Hit Radius",
        default = 0.1,
        min= 0.1,
        step=10,
        subtype='DISTANCE',
        update = update_radius
    )
    bpy.types.PoseBone.vrmprop_show_hit = bpy.props.BoolProperty(
        name = "Show", 
        default = True,
        update = update_show_hit
    )
    bpy.types.PoseBone.vrmprop_spring_id = bpy.props.StringProperty(
        name= "Spring id",
        default= "kdbaisi"
    )
    bpy.types.PoseBone.vrmprop_collider_name = bpy.props.StringProperty(
        name= "Collider Name",
        default= "Collider",
        update = update_collider_name
    )
    bpy.types.PoseBone.vrmprop_collider_id = bpy.props.StringProperty(
        name= "Collider id",
        default= "kdbaisi"
    )
    bpy.types.Armature.vrmprop_grub_collider = bpy.props.CollectionProperty(type=collider_grub)
    bpy.types.PoseBone.vrmprop_collider = bpy.props.CollectionProperty(type=jinggle_collider)
    bpy.types.PoseBone.vrmprop_colliders = bpy.props.CollectionProperty(type=colliders)
    bpy.types.PoseBone.vrmprop_collider_pilih = bpy.props.IntProperty(name = "Pilih", default = 0)
    bpy.types.PoseBone.vrmprop_colliders_pilih = bpy.props.IntProperty(name = "Pilih", default = -1, max= -1, update = update_colliders)
    bpy.types.Object.vrmprop_colliders_view = bpy.props.BoolProperty(name = "colliders_preview", default = False)

def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)

if __name__ == "__main__":
    register()